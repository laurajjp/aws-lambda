# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/62_ml.predict.ipynb (unless otherwise specified).

__all__ = ['predict_window', 'predict_windowed']

# Cell
from tqdm import tqdm
import numpy as np
import pandas as pd
import rasterio


def predict_window(data, model, bandnames):
    """
    Predict the value of each pixel in a window using an ml model.
    """
    # rearrange data to be compatible with the model
    img_swp = np.moveaxis(data, 0, 2)
    img_flat = img_swp.reshape(-1, img_swp.shape[-1])
    img_w_ind = img_flat
    to_predict = img_w_ind
    # predict
    df = pd.DataFrame(data=to_predict, columns=bandnames)
    img_preds = model.predict(df)
    # reshape the prediction to the original shape
    output = np.zeros(img_flat.shape[0])
    output = img_preds.flatten()
    output = output.reshape(*img_swp.shape[:-1])
    return output


def predict_windowed(src_images, output_image, model, bandnames, window_size=500):
    """
    Predict from a ML model on a raster image using several input tifs.

    Args:
        src_images: list of tifs / rasterio.open() objects.
        output_image: result tif / rasterio.open() object.
        model: sklearn model.
        bandnames: list of band names.
        window_size: size of the window to use for prediction.
    """
    # read profile from first image
    with rasterio.open(src_images[0], "r") as src:
        profile = src.profile
        profile.update(dtype=rasterio.float32, count=1)
    # perform prediction on each image window to minimize required memory
    with rasterio.open(output_image, "w", **profile) as dst:
        # loop over windows
        for i in tqdm(range((src.shape[0] // window_size) + 1)):
            for j in tqdm(range((src.shape[1] // window_size) + 1), leave=False):
                # define the pixels to read (and write)
                window = rasterio.windows.Window(
                    j * window_size,
                    i * window_size,
                    # don't read past the image bounds
                    min(window_size, src.shape[1] - j * window_size),
                    min(window_size, src.shape[0] - i * window_size),
                )
                # read the pixels
                window_band_arrays = []
                for src_image in src_images:
                    with rasterio.open(src_image, "r") as band_src:
                        band_data = band_src.read(window=window)
                        window_band_arrays.append(band_data)
                # concatenate the bands
                data = np.concatenate(window_band_arrays)
                # predict
                output = predict_window(data, model, bandnames)
                # write prediction to output image
                dst.write(output.astype(rasterio.float32), 1, window=window)
    return output_image