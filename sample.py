# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/60_ml.sample.ipynb (unless otherwise specified).

__all__ = ['sample_gdf', 'sample_raster', 'sampler', 'sample_region', 'sample_raster2csv']

# Cell
from datetime import datetime
from fastcore.test import test_eq
from functools import partial
from multiprocessing import Pool
from multiprocessing.pool import ThreadPool
from pyproj import crs
from rasterio import windows
from rasterio.features import rasterize
from retry import retry
from shapely.geometry import shape
from tqdm.notebook import tqdm
import time
import csv
import geopandas as gpd
import numpy as np
import pandas as pd
import os
import rasterio
import rioxarray as rxr
import shapely
import shutil
import time

# Cell
def sample_gdf(polygon, raster, properties=None, stat='mean'):
    """Given a polygon extracts a csv with the polygon fields + the raster values"""
    samples = []
    if not properties:
        properties = list(polygon.keys())
    props = [polygon[prop] for prop in properties]

    left, bottom, right, top = shapely.geometry.shape(polygon["geometry"]).bounds
    raster_transform = raster.transform
    window = rasterio.windows.from_bounds(
        left=left, bottom=bottom, right=right, top=top, transform=raster_transform
    )  # window of the raster to open
    transform = rasterio.windows.transform(
        window, raster_transform
    )  # appropriate transform for rasterize

    subset = raster.read(window=window)  # open small window of the raster
    w, h = subset.shape[1:]
    if not (w > 0 and h > 0):
        return [np.nan] + props
    mask = rasterio.features.rasterize(
        [(polygon["geometry"], 1)],
        out_shape=subset.shape[1:],
        transform=transform,
        fill=0,
        dtype="uint8",
        all_touched=True,
    ).astype(bool)
    for row, col in np.argwhere(mask):
        data = subset[:, row, col]
        samples.append(list(data) + props)
    samples_stack = np.stack(samples).T
    if stat=='median':
        return samples_stack.median(axis=1)
    elif stat=='max':
        return samples_stack.max(axis=1)
    elif stat=='min':
        return samples_stack.min(axis=1)
    else:  # stat=='mean'
        return samples_stack.mean(axis=1)


@retry(tries=10, delay=1, backoff=2)
def sample_raster(args):
    gdf, raster, bandname, id_column, stat, tmp_dir = args
    cols = [bandname, id_column]
    ds = rasterio.open(raster)
    samples = gdf.apply(sample_gdf, raster=ds, properties=[id_column], stat=stat, axis=1)
    raster_samples = pd.DataFrame(samples.tolist(), columns=cols)
    raster_samples.to_feather(f'{tmp_dir}/raster_{bandname}.feather')


# Cell

def sampler(
    gdf,
    rasters,
    bandnames,
    stat='mean',
    remove_tmp=True,
    n_processes=8,
):
    """
    Args:
        - gdf (GeoDataFrame): polygons for sampling, with attributes on an id_column, e.g. the GEDI shot_number, and a geometry per shot.
        - rasters (lst): list of raster file paths or urls (str).
        - bandnames (lst): list of band names (str) that correspond to rasters
        - stat (str): 'mean', 'median', 'max', 'min' (default: 'mean').
        - remove_tmp (bool): whether to remove the temporary directory (default: True).
        - n_processes (int): number of processes to use in the threadpool (default: 8).
    returns:
        - samples (GeoDataFrame): sampled gdf with added columns for each raster file.
    """
    area_names = bandnames[0].split('_bbox_')
    if len(area_names)>1:
        area = area_names[1].replace('.tif', '')
    else:
        area = bandnames[0].replace('.tif', '')
    version = datetime.now().isoformat().replace(":", "").replace('.', '_')
    tmp_dir = f'tmp_{version}'
    os.makedirs(tmp_dir, exist_ok=True)
    id_column = 'index'  # ensure unique index column (because shot_numbers can go beyond int64)
    if not id_column in gdf.columns:
        gdf = gdf.reset_index(drop=True).reset_index()
    # Setup partial function for multiprocessing
    if len(rasters)<n_processes:
        n_processes = len(rasters)
    sample_raster_partial = partial(sample_raster)
    args_repeated = [(gdf, raster, bandname, id_column, stat, tmp_dir)
                     for raster, bandname in zip(rasters, bandnames)]
    for _ in tqdm(
        ThreadPool(n_processes).imap_unordered(
            sample_raster_partial, args_repeated),
        total=len(rasters),
        desc=f"sampling {area}: ",
    ):
        pass
    # concatenate all the samples
    sampled_rasters = [pd.read_feather(f'{tmp_dir}/raster_{bandname}.feather')
                       for bandname in bandnames]
    for raster_samples in sampled_rasters:
        gdf = gdf.merge(raster_samples, on=id_column)
    if remove_tmp:
        # remove tmp dir and feather files for each raster
        shutil.rmtree(tmp_dir)
    # return the sampled gdf
    return gdf


# Cell
def sample_region(raster, polygon):
    """
    Args:
        - raster (geotiff): raster to sample
        - polygon (shapely.geometry.Polygon): polygon to sample

    Returns:
        - np.array with sampled values
    """
    samples = []
    left, bottom, right, top = shape(polygon["geometry"]).bounds
    window = windows.from_bounds(
        left=left, bottom=bottom, right=right, top=top, transform=ds.transform
    )  # window of the raster to open
    transform = windows.transform(
        window, raster.transform
    )  # appropriate transform for rasterize

    subset = raster.read(window=window)  # open small window of the raster

    mask = rasterize(
        [(polygon["geometry"], 1)],
        out_shape=subset.shape[1:],
        transform=transform,
        fill=0,
        dtype="uint8",
        all_touched=True,
    ).astype(bool)

    samples = [
        np.extract(mask, subset[i]) for i in range(subset.shape[0])
    ]  # sample for every band

    return np.stack(samples).T  # stack and turn rows to cols

# Cell
def sample_raster2csv(raster, polygon, properties=None, out_dir=None):
    if not properties:
        properties = [col for col in gdf.columns if col != "geometry"]
    samples = sample_region(raster, polygon)
    #     samples = list(samples)

    props = [polygon[prop] for prop in properties]
    samples = [list(x) + props for x in samples]
    band_names = raster.descriptions
    if band_names[0] == None:  # if the bands have no descriptions:
        band_names = [f"b{n}" for n, _ in enumerate(raster.descriptions)]

    with open(out_dir + f"/sample_{polygon.name}", "w") as f:
        writer = csv.writer(f, delimiter=",")
        writer.writerows([band_names + properties])  # header
        writer.writerows(samples)
